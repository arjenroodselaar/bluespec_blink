//
// Generated by Bluespec Compiler, version 2024.07 (build b4f31db)
//
// On Sun Dec 29 13:00:43 PST 2024
//
//
// Ports:
// Name                         I/O  size props
// led                            O     8 reg
// ftdi_rxd                       O     1 reg
// wifi_gpio0                     O     1 const
// clk_25mhz                      I     1 clock
// user_programn                  I     1 reset
// btn                            I     7 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBlink(clk_25mhz,
	       user_programn,

	       btn,

	       led,

	       ftdi_rxd,

	       wifi_gpio0);
  input  clk_25mhz;
  input  user_programn;

  // action method readButtons
  input  [6 : 0] btn;

  // value method led
  output [7 : 0] led;

  // value method uart_tx
  output ftdi_rxd;

  // value method dont_reboot
  output wifi_gpio0;

  // signals for module outputs
  wire [7 : 0] led;
  wire ftdi_rxd, wifi_gpio0;

  // register buttons
  reg [6 : 0] buttons;
  wire [6 : 0] buttons$D_IN;
  wire buttons$EN;

  // register leds
  reg [7 : 0] leds;
  wire [7 : 0] leds$D_IN;
  wire leds$EN;

  // register tx_bitc
  reg [3 : 0] tx_bitc;
  wire [3 : 0] tx_bitc$D_IN;
  wire tx_bitc$EN;

  // register tx_cyclec
  reg [7 : 0] tx_cyclec;
  wire [7 : 0] tx_cyclec$D_IN;
  wire tx_cyclec$EN;

  // register tx_tx
  reg tx_tx;
  wire tx_tx$D_IN, tx_tx$EN;

  // register tx_txBit
  reg [7 : 0] tx_txBit;
  wire [7 : 0] tx_txBit$D_IN;
  wire tx_txBit$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_generate_new, WILL_FIRE_RL_tx_shift_bits;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_tx_cyclec$write_1__VAL_1,
	       MUX_tx_txBit$write_1__VAL_1,
	       MUX_tx_txBit$write_1__VAL_2;
  wire [3 : 0] MUX_tx_bitc$write_1__VAL_1;

  // value method led
  assign led = leds ;

  // value method uart_tx
  assign ftdi_rxd = tx_tx ;

  // value method dont_reboot
  assign wifi_gpio0 = 1'd1 ;

  // rule RL_generate_new
  assign WILL_FIRE_RL_generate_new =
	     tx_cyclec == 8'd0 && tx_bitc == 4'd0 && !buttons[0] ;

  // rule RL_tx_shift_bits
  assign WILL_FIRE_RL_tx_shift_bits = tx_cyclec == 8'd0 && tx_bitc != 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_tx_bitc$write_1__VAL_1 = tx_bitc - 4'd1 ;
  assign MUX_tx_cyclec$write_1__VAL_1 = tx_cyclec - 8'd1 ;
  assign MUX_tx_txBit$write_1__VAL_1 = { 1'd1, tx_txBit[7:1] } ;
  assign MUX_tx_txBit$write_1__VAL_2 = { 2'd1, leds[5:0] } ;

  // register buttons
  assign buttons$D_IN = btn ;
  assign buttons$EN = 1'd1 ;

  // register leds
  assign leds$D_IN = leds + 8'd1 ;
  assign leds$EN = WILL_FIRE_RL_generate_new ;

  // register tx_bitc
  assign tx_bitc$D_IN =
	     WILL_FIRE_RL_tx_shift_bits ? MUX_tx_bitc$write_1__VAL_1 : 4'd9 ;
  assign tx_bitc$EN =
	     WILL_FIRE_RL_tx_shift_bits || WILL_FIRE_RL_generate_new ;

  // register tx_cyclec
  assign tx_cyclec$D_IN =
	     (tx_cyclec != 8'd0) ? MUX_tx_cyclec$write_1__VAL_1 : 8'd108 ;
  assign tx_cyclec$EN =
	     tx_cyclec != 8'd0 || WILL_FIRE_RL_generate_new ||
	     WILL_FIRE_RL_tx_shift_bits ;

  // register tx_tx
  assign tx_tx$D_IN = WILL_FIRE_RL_tx_shift_bits && tx_txBit[0] ;
  assign tx_tx$EN = WILL_FIRE_RL_tx_shift_bits || WILL_FIRE_RL_generate_new ;

  // register tx_txBit
  assign tx_txBit$D_IN =
	     WILL_FIRE_RL_tx_shift_bits ?
	       MUX_tx_txBit$write_1__VAL_1 :
	       MUX_tx_txBit$write_1__VAL_2 ;
  assign tx_txBit$EN =
	     WILL_FIRE_RL_tx_shift_bits || WILL_FIRE_RL_generate_new ;

  // handling of inlined registers

  always@(posedge clk_25mhz)
  begin
    if (user_programn == `BSV_RESET_VALUE)
      begin
        tx_bitc <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tx_cyclec <= `BSV_ASSIGNMENT_DELAY 8'd0;
	tx_tx <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (tx_bitc$EN) tx_bitc <= `BSV_ASSIGNMENT_DELAY tx_bitc$D_IN;
	if (tx_cyclec$EN) tx_cyclec <= `BSV_ASSIGNMENT_DELAY tx_cyclec$D_IN;
	if (tx_tx$EN) tx_tx <= `BSV_ASSIGNMENT_DELAY tx_tx$D_IN;
      end
    if (buttons$EN) buttons <= `BSV_ASSIGNMENT_DELAY buttons$D_IN;
    if (leds$EN) leds <= `BSV_ASSIGNMENT_DELAY leds$D_IN;
    if (tx_txBit$EN) tx_txBit <= `BSV_ASSIGNMENT_DELAY tx_txBit$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    buttons = 7'h2A;
    leds = 8'hAA;
    tx_bitc = 4'hA;
    tx_cyclec = 8'hAA;
    tx_tx = 1'h0;
    tx_txBit = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBlink

